/**
 * Copyright (c) 2008-2010  Morten Silcowitz.
 *
 * This file is part of the Jinngine physics library
 *
 * Jinngine is published under the GPL license, available 
 * at http://www.gnu.org/copyleft/gpl.html. 
 */
package jinngine.physics.solver;
import java.util.*;

import jinngine.math.Vector3;
import jinngine.physics.*;

/**
 * Solver for a non-linear complimentarity problem (NCP).<p>
 *   
 * The contact force problem generated by Jinngine is ultimately a non-linear complementarity problem. In 
 * fact, when disregarding the coupling between friction forces and normal forces, the problem becomes a
 * mixed linear complementarity problem, or MLCP for short. The MLCP is on the form 
 * <p>
 * Given the matrix <b>A</b>, the vector b, and the solution limit vectors l and u,
 * Find x, such that
 * <p>
 *  w = <b>A</b> x + b 
 * <p>
 *  where
 * <p>
 *   if x_i=u_i  then  w_i<=0 <br>
 *   if x_i in (l_i,u_i) then w_i = 0 <br>
 *   if x_i=l_i then w_i>=0 <p>
 *  
 *  <b>A</b> is the matrix <b>J M^(-1) J^T</b> which describes constraint relations, 
 *  and b is the vector of desired change in velocities. 
 * <p>
 * 
 * This problem class can model normal-component contact forces and various joint types. The 
 * reason why this becomes a NCP when contact friction is introduced, is that we allow u and l 
 * to depend on the magnitude of some x_i vales, namely the x_i's that represent normal contact 
 * forces, so 
 * <p>
 * 
 * l_i = -|mu * x_j|  and  u_i = |mu*x_j|
 * <p>
 * 
 * where i is the index of a friction constraint, j is the index of the normal force, and mu is 
 * the friction coefficient. constraint to which the friction constraint is coupled. This coupling 
 * is done to model an approximation to Coulomb's law of friction. 
 */
public interface Solver {
	
	/**
	 * Given a list of constraints, solve the corresponding NCP 
	 * @param constraints List of constraints
	 * @param epsilon TODO
	 * @return error
	 */
	public double solve(List<NCPConstraint> constraints, List<Body> bodies, double epsilon );
	
	/**
	 * Set an upper limit on the number of (usually outer) iterations, 
	 * that this solver is allowed to perform. 
	 * @param n
	 */
	public void setMaximumIterations( int n );
	
	/**
	 * A constraint definition involving a pair of bodies. A list of Solver.constraint 
	 * defines an NCP problem to be solved.
	 */
	public final class NCPConstraint  {
		/** Involved body pair */
		public Body body1,body2; 
		/** Jacobian, 1 by 12 matrix */
		public final Vector3 j1=new Vector3(), j2=new Vector3(), j3=new Vector3(), j4=new Vector3();
		/** The 12 by 1 B matrix, where B = M^-1 J^T */
		public final Vector3 b1=new Vector3(), b2=new Vector3(), b3=new Vector3(), b4=new Vector3();	
		/** Solution lambda value */
		public double lambda = 0;
		/** The lower limit u value */
		public double lower = 0;
		/** The upper limit u value */
		public double upper = 0;
		/** The diagonal element A_i,i = JB*/ 
		public double diagonal = 0;
		/** b vector value */ 
		public double b = 0;
		/** correction term */
		public double c = 0;
		/** Friction coefficient mu. Only in effect if coupling is not null */
		public double mu = 0;
		/** Friction coupling */
		public NCPConstraint coupling;
		/** Damping coefficient */
		public double damper = 0;
		/** External force impulse */
		public double Fext;
		
		
		// Auxiliary variables. These variables is included to aid the implementation of solvers. 
		/** The Fischer reformulation value */
		public double fischer;
		/** Residual, r = b - Ax */
		public double residual; 
		public double d;
		public double q;
		public double z;
		public double dlambda;
		public double bestdlambda;
		public double s;
		public double u;
		public double l;
		public double distance;
		
		/**
		 * Assign operator for a constraint
		 * @param c TODO
		 */
		public final NCPConstraint assign( Body body1, Body body2, Vector3 b1, Vector3 b2, Vector3 b3, Vector3 b4, 
				Vector3 j1, Vector3 j2, Vector3 j3, Vector3 j4,
				double lambdaMin, double lambdaMax, NCPConstraint coupledMax, double b, double c ) {
			
			this.body1 = body1;
			this.body2 = body2;
			this.b1.assign(b1);
			this.b2.assign(b2);
			this.b3.assign(b3);
			this.b4.assign(b4);
			this.j1.assign(j1);
			this.j2.assign(j2);
			this.j3.assign(j3);
			this.j4.assign(j4);
			this.lambda = 0;
			this.lower = lambdaMin;
			this.upper = lambdaMax;
			this.coupling = coupledMax;
			this.b = b;
			this.c = c;
			this.diagonal = j1.dot(b1) + j2.dot(b2) +  j3.dot(b3) + j4.dot(b4);
			return this;
		}
	}

}
